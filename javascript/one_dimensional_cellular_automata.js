/* 

  One-dimensional cellular automata in JavaScript.

  http://rosettacode.org/wiki/One-dimensional_cellular_automata
  """
  Assume an array of cells with an initial distribution of live and dead cells, and 
  imaginary cells off the end of the array having fixed values.

  Cells in the next generation of the array are calculated based on the value of 
  the cell and its left and right nearest neighbours in the current generation.

  If, in the following table, a live cell is represented by 1 and a dead cell 
  by 0 then to generate the value of the cell at a particular index in the array 
  of cellular values you use the following table:

  000 -> 0  # 
  001 -> 0  #
  010 -> 0  # Dies without enough neighbours
  011 -> 1  # Needs one neighbour to survive
  100 -> 0  #
  101 -> 1  # Two neighbours giving birth
  110 -> 1  # Needs one neighbour to survive
  111 -> 0  # Starved to death.
  """

  This JavaScript program was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my JavaScript page: http://www.hakank.org/javascript_progs/

*/

'use strict';
const {randomInt,zip,range,range2} = require('./js_utils.js');

// From the task
// This is rule 104
const rule1 = {"000": "0", // 
               "001": "0", //
               "010": "0", // Dies without enough neighbours
               "011": "1", // Needs one neighbour to survive
               "100": "0", //
               "101": "1", // Two neighbours giving birth
               "110": "1", // Needs one neighbour to survive
               "111": "0"  // Starved to death.
              };

// rule 30
/*
  {"000":"0",
   "001":"1",
   "010":"1",
   "011":"1",
   "100":"1",
   "101":"0",
   "110":"0",
   "111":"0"
  }
*/
const rule30 = get_rule(30);

// static init string (from many of the Rosetta code entries)
const init1 = "01110110101010100100";

//
// convert 0,1 -> _,#
//
function convert(s) {
    return s.replace(/1/g,"#").replace(/0/g,"_")
}

//
// generate a random instance of length len
//
function random_instance(len) {
    let s = "";
    for(let i = 0; i < len; i++) {
        s += Math.floor(Math.random()*2).toString();
    }
    return s;
}

//
// Get the rule number: it's the bit pattern of the values for
// ['111', '110','101', '100', '011', '010', '001', '000']
//
function rule_number(rules) {
    return parseInt(Object.keys(rules).sort((a,b)=>b-a).map(k=>rules[k]).join(""),2);
}

//
// Create the rules for rule n
//
function get_rule(n) {
    const p = ['111', '110','101', '100', '011', '010', '001', '000'];
    const bin = (n).toString(2).padStart(8,0).split(""); // pad for 8 bit
    const h = {};
    zip([p,bin])
        .forEach(([p,v])=>h[p]=v);
    return h;
}

//
// generate a random rule (from 0..255)
//
function random_rule() {
    return get_rule(randomInt(255));
}

//
// print the patterns
//
function print_patterns(patterns) {
    patterns
        .forEach(p=>console.log(p));
    console.log("\nlength:", patterns.length);
}

//
// one pass of the ca (not used)
//
function ca1(s,rules) {
    let len = s.length;
    let snew = s.slice(0,1); // first char is copied
    // for each triplet in 1..len-1: replace the found pattern
    for(let i = 1; i < len-1; i++) {
        let next = s.slice(i-1,i+2);
        for(let r of Object.keys(rules)) {
            if (next === r) {
                snew += rules[r];
                break;
            }
        }
    }
    // and copy the last character
    return snew += s.slice(-1);
    
}

//
// One ca pass. A bit nicer
//
function ca2(s,rules) {
    let len = s.length;
    return s.slice(0,1) +
        range2(1,len-1).map(i=>rules[s.slice(i-1,i+2)]).join("") +
        s.slice(-1);
}


//
// run ca until we've seen a previous pattern
//
function ca(init,rules) {
    let s = init;
    let seen = {}; // which patterns have we seen already?
    let patterns = [];
    while (true) {
        s = ca2(s,rules);
        patterns.push(convert(s));
        if (seen[s]) {
            break;
        }
        seen[s] = 1;
    }
    return patterns;
} 


console.log("init 1, rule 1:");
console.log("rule1 is ", rule_number(rule1));
print_patterns(ca(init1,rule1));
let patterns = ca(random_instance(20),rule1);
print_patterns(patterns);

// Rule 30 is more interesting than rule 104 (the given rule in the task).
// console.log("\nrandom instance, rule 30:");
// ca(init1,rule30);
// ca(random_instance(50),rule30);

// random rules, random instance
const rr = random_rule();
const rule_num = rule_number(rr);
console.log("\nrandom rule:\n", rr,"\nrule number:", rule_num);
patterns = ca(init1,rr);
print_patterns(patterns);
console.log("\nThat was rule number ", rule_num);

// Check the pattern lengths for all rules (0..255).
console.log("\nLengths of pattern generated by the different rules 0..255.");
console.log("Sorted by length of patterns for i");
console.log(range(256)
            .map(rnum=>[rnum, ca(init1,get_rule(rnum)).length])
            .sort((a,b)=>b[1]-a[1])
            .map(r=>`rule ${r[0]} length: ${r[1]}`));
