/*

  Number of dice throws until a target number is reached.

  What is the number of dice throws needed to reach a cumulative
  sum larger or equal to a target number.

*/

// target: 6
// E[s,n] = (117649/15552,9031/7776)
// (~7.56487911522633744856,~1.16139403292181069959)
//
// target: 10
// E[s,n] = (234466225/20155392,23417479/10077696)
// (11.632928052205584, 2.323693729201595)

// target: 60
// E[s,n] = (6125500973841052535295228453167877325760166030055/97747355961378514978645504547549207731321700352,826197889710889676124281312464493585528648582689/48873677980689257489322752273774603865660850176)
// (62.666666669340216, 16.904761905525774)

// target: 100
// E[s,n] = (22140242240835741201995008159294008429041770388139615412718012208302419384155553/217772874500023635365563422386019273512381236824318290514357322123165713825792,3054005311440808354030790882991848710249776579893500199416823082981619912252183/108886437250011817682781711193009636756190618412159145257178661061582856912896)
// (101.66666666666669, 28.047619047619055)

// target: 200
// E[s,n] = (3538587142572576578972959533036622213413626801222211703069451236768772321195081500900789291862156661948292243482847630108624262047097874195842186651946443175787520459142305448288611231465879877344289895144738696957985377881163699/17546713103665668986642774544022315195431566738075986231861422072275694709579901290996453354040021784222948246345221415369225233976680768213518924342619642926083022795442617439048235072888275743992807502781344330785907839860736,31962553893275102830123687813132432753613998714486928397341297362340396459308432425804752740361224323676158183777469769944154146876124692600820041831596295944845522029959820610575985110387001615144984382512442740795271213209810796001971976024559628847571439153269749668432369431024969982861608640877579321520922913454252959351093503440895983496472313722079540252923843249039022459778903594962429480471132132305889468000431374581863079103979314708516964239705968814006346891322218617694929471813334830726982029949477738583069865178506623306911829/564519454801326458732209793168462418093712678461472734944085836164016274822135865180165990058537488027423109797891919064863861222239764861836162692909187598610598105019450854944934608519724737281112885007072471392284909918784195788936670007472901266686131219592592254223950717195288676904029281465553650176001354926400223983181213538721996084164835553341416985515194784167607154443202989193648584398196295492817897953703679812870745050796348978360849342155768293400049975361014127177378875781097610253630832889606807158515318636414789197234176)
// (201.66666666666666, 56.61904761904762)



// use --dp 
// The while loop is only supported with --dp
def throw(target) {
  s := uniformInt(1,6);
  n := 0;
  while s < target {
    s += uniformInt(1,6);
    n += 1;
  }

  return(s,
         n
         );

}

// Using array concatenation works as well.
// Note that we need to have a fixed number for
// the for loop.
// This is much slower than throw(target)
// See the timings below.
def throw2(target) {
  a := [];
  n := 0;  
  s := 0;
  // Need a fix number for the for loop.
  nums := target div 2; 
  for i in [0..target) {
    if s < target {
      t := uniformInt(1,6);
      a ~= [t];
      s += t;
      n += 1; // same as a.length
    }
  }

  return(
        s,
        a.length
         );

}

/*
def throw1() {
  return uniformInt(1,6);
}

// Recursion don't work
def throw(s) {
   ss := s;
   if ss < 16 {
     t := throw1();
     ss += throw(ss);
   }
   return ss;
}
*/

def main() {
  return
     // with --dp
     throw(6); // 0.057s
     // throw(10); // 0.081s
     // throw(61); // 1.704s
     // throw(100); // 5.322s
     // throw(200); // 29.649s
     // throw(500); // Seg faults after 2min
     // throw(1000); // Seg faults

     // with --dp
     // This is much slower!
     // throw2(6); // 0.151s
     // throw2(10); // 3.613s
     // throw2(61); // > 6min (stopped it after 6min40s)
     // throw2(100);
     // throw2(200);
     

}